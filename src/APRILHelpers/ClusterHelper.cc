/// \file ClusterHelper.cc
/*
 *
 * ClusterHelper.cc source template automatically generated by a class generator
 * Creation date : ven. avr. 10 2015
 * Updated november 2023 by Tanguy Pasquier
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/CaloHitHelper.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/ReclusterHelper.h"
#include "APRILHelpers/CaloHitNeighborSearchHelper.h"

#include "TMatrixT.h"
#include "TMatrixDEigen.h"
#include "TVectorD.h"

#include "TVector3.h"
#include "TRotation.h"
#include "TH2F.h"

namespace april_content
{

  ClusterPca::Component::Component() :
      m_eigenValue(0.f),
      m_eigenVector(0.f, 0.f, 0.f)
  {
    /* nop */
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  ClusterPca::ClusterPca(const pandora::Cluster *const pCluster) :
		    m_pCluster(pCluster)
  {
    if(NULL == pCluster || 2 > pCluster->GetNCaloHits())
      throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    float mean[3] = {0.f};

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    const unsigned nDofs(clusterCaloHitList.size());

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      mean[0] += pCaloHit->GetPositionVector().GetX();
      mean[1] += pCaloHit->GetPositionVector().GetY();
      mean[2] += pCaloHit->GetPositionVector().GetZ();
    }

    mean[0] /= nDofs;
    mean[1] /= nDofs;
    mean[2] /= nDofs;

    TMatrixD covarianceMatrix(3, 3);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      float x(pCaloHit->GetPositionVector().GetX() - mean[0]);
      float y(pCaloHit->GetPositionVector().GetY() - mean[1]);
      float z(pCaloHit->GetPositionVector().GetZ() - mean[2]);

      covarianceMatrix(0, 0) += ((x*x) / nDofs);
      covarianceMatrix(1, 1) += ((y*y) / nDofs);
      covarianceMatrix(2, 2) += ((z*z) / nDofs);

      covarianceMatrix(0, 1) += ((x*y) / nDofs);
      covarianceMatrix(0, 2) += ((x*z) / nDofs);
      covarianceMatrix(1, 2) += ((y*z) / nDofs);
    }

    covarianceMatrix(1, 0) = covarianceMatrix(0, 1);
    covarianceMatrix(2, 0) = covarianceMatrix(0, 2);
    covarianceMatrix(2, 1) = covarianceMatrix(1, 2);

    TMatrixDEigen eigenMatrix(covarianceMatrix);

    for(unsigned int i=0 ; i<3 ; i++)
    {
      m_components[i].m_eigenValue = eigenMatrix.GetEigenValuesRe()[i];

      const float x(eigenMatrix.GetEigenVectors()[i][0]);
      const float y(eigenMatrix.GetEigenVectors()[i][1]);
      const float z(eigenMatrix.GetEigenVectors()[i][2]);

      m_components[i].m_eigenVector.SetValues(x, y, z);

      //		std::cout << "Eigen val [" << i << "] : val = " << m_components[i].m_eigenValue << " , vec = " << m_components[i].m_eigenVector << std::endl;
    }

    m_transverseRatio = std::sqrt(m_components[2].m_eigenValue*m_components[2].m_eigenValue + m_components[1].m_eigenValue*m_components[1].m_eigenValue) / m_components[0].m_eigenValue;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::GetTrackClusterDistance(const pandora::TrackState *const pTrackState, const pandora::Cluster *const pCluster, const unsigned int maxSearchLayer, const float parallelDistanceCut, const float minTrackClusterCosAngle, float &trackClusterDistance)
  {
       if ((0 == pCluster->GetNCaloHits()) || (pCluster->GetInnerPseudoLayer() > maxSearchLayer))
           return pandora::STATUS_CODE_NOT_FOUND;
   
       const pandora::CartesianVector &trackPosition(pTrackState->GetPosition());
       const pandora::CartesianVector trackDirection(pTrackState->GetMomentum().GetUnitVector());
   
       if (trackDirection.GetCosOpeningAngle(pCluster->GetInitialDirection()) < minTrackClusterCosAngle)
           return pandora::STATUS_CODE_NOT_FOUND;
   
       bool distanceFound(false);
       float minDistanceSquared(std::numeric_limits<float>::max());
       const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
   
       for (pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), iterEnd = orderedCaloHitList.end(); iter != iterEnd; ++iter)
       {   
           if (iter->first > maxSearchLayer)
               break;
   
           for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end(); hitIter != hitIterEnd; ++hitIter)
           {
               const pandora::CartesianVector positionDifference((*hitIter)->GetPositionVector() - trackPosition);
   
               if (std::fabs(trackDirection.GetDotProduct(positionDifference)) > parallelDistanceCut)
                   continue;
   
               const float perpendicularDistanceSquared((trackDirection.GetCrossProduct(positionDifference)).GetMagnitudeSquared());
   
               if (perpendicularDistanceSquared < minDistanceSquared)
               {
                   minDistanceSquared = perpendicularDistanceSquared;
                   distanceFound = true;
               }
           }
       }
   
       if (!distanceFound)
           return pandora::STATUS_CODE_NOT_FOUND;
   
       trackClusterDistance = std::sqrt(minDistanceSquared);
       return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  void ClusterHelper::GetShowerStartingLayer(const pandora::Cluster *const pCluster, int& showerStartLayer)
  {
	// code from shower plugin
	
    showerStartLayer = std::numeric_limits<unsigned int>::max();

    const unsigned int innerLayer(pCluster->GetInnerPseudoLayer()), outerLayer(pCluster->GetOuterPseudoLayer());
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    TH1F hist("h", "layer", outerLayer-innerLayer, innerLayer, outerLayer);	

    for (unsigned int iLayer = innerLayer; iLayer <= outerLayer; ++iLayer)
    {
		pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.find(iLayer);
        int nHits = iter->second->size();

		hist.Fill(iLayer, nHits);
	}

    int maxBin = hist.GetMaximumBin();

	if(hist.GetBinContent(maxBin) <= 4) showerStartLayer = 0;

	int nHitsOn3Layer = hist.GetBinContent(maxBin-1) + hist.GetBinContent(maxBin) + hist.GetBinContent(maxBin+1);
	// FIXME
        if(float(nHitsOn3Layer)/3 < 5.) showerStartLayer = 0;

	if(showerStartLayer != 0)
	{   
	    int start = 1; 
	    int maxHits = 4;

        for(int bin=maxBin-1; bin>0; --bin)
        {   
	    	bool passedCheck = true;

	    	for(int checkBin = 1; checkBin <= bin; ++checkBin)
	    	{
	    		if(hist.GetBinContent(checkBin) > maxHits)
	    		{
	    			passedCheck = false;
	    			break;
	    		}
	    	}

            if(passedCheck)
            {
                start = bin;
                break;
            }
        }   

        showerStartLayer = start;
	}
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  void ClusterHelper::GetShowerStartingPoint(const pandora::Cluster *const pCluster, pandora::CartesianVector& startingPoint)
  {
      int showerStartingLayer = 0;
	  GetShowerStartingLayer(pCluster, showerStartingLayer);

	  startingPoint.SetValues(0., 0., 0.);

	  if(showerStartingLayer==0) return;
		
      const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
	  pandora::OrderedCaloHitList::const_iterator iterShowerStarting = orderedCaloHitList.find(showerStartingLayer);

	  auto hits = iterShowerStarting->second;
	  int nHits = 0;

	  for(auto& hit : *hits)
	  {
		  startingPoint += hit->GetPositionVector();
		  ++nHits;
	  }

	  float weight = 1./nHits;

	  startingPoint *= weight;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  float ClusterHelper::GetClusterAxisStartingPointAngle(const pandora::Cluster *const pCluster)
  {
	  float angleAxisStartingPoint = 1.e6;

	  const APRILCluster* pAPRILCluster = APRILContentApi::Modifiable(dynamic_cast<const april_content::APRILCluster*>(pCluster));

	  if(pAPRILCluster == nullptr) return angleAxisStartingPoint;

	  auto& clusterAxis = pAPRILCluster->GetAxis();
	  auto& clusterStartingPoint = pAPRILCluster->GetStartingPoint();

	  if(clusterAxis.GetMagnitude() > 1.e-3 && clusterStartingPoint.GetMagnitude() > 1.e-3)
	  {
		  angleAxisStartingPoint = clusterAxis.GetOpeningAngle(clusterStartingPoint);
	  }

	  return angleAxisStartingPoint;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCentroid(const pandora::Cluster *const pCluster, pandora::CartesianVector &centroid)
  {
#if 0
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for(pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), endIter = orderedCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      centroid += pCluster->GetCentroid(iter->first);
    }

    centroid *= 1.f/(orderedCaloHitList.size());
#endif

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

	const pandora::CaloHitList& isolatedCaloHitList = pCluster->GetIsolatedCaloHitList();
	clusterCaloHitList.insert(clusterCaloHitList.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

	unsigned int nHits = 0;

	pandora::CartesianVector cluCentroid(0., 0., 0.);
	pandora::CartesianVector cluCentroidWithConnector(0., 0., 0.);

  for(auto caloHit : clusterCaloHitList)
	{
		const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(caloHit));
		cluCentroid += pCaloHit->GetPositionVector();
  
		 if(APRILContentApi::HasAnyConnection(pCaloHit))
		{
			cluCentroidWithConnector += pCaloHit->GetPositionVector();
			++nHits;
		} 
	}

	if(nHits>=2)
	{
	  centroid = cluCentroidWithConnector * (1./nHits);
	}
	else
	{
		centroid = cluCentroid * (1./clusterCaloHitList.size());
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  bool ClusterHelper::CanMergeCluster(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, 
		  const float minMipFraction, const float maxAllHitsFitRms)
  {
      if (0 == pCluster->GetNCaloHits())
          return false;
  
      if (!(pCluster->PassPhotonId(pandora)))
          return true;
  
      if (pCluster->GetMipFraction() - minMipFraction > std::numeric_limits<float>::epsilon())
          return true;
  
      return (pCluster->GetFitToAllHitsResult().IsFitSuccessful() && (pCluster->GetFitToAllHitsResult().GetRms() < maxAllHitsFitRms));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::OrderedCaloHitList ClusterHelper::GetOrderedConnectedCaloHitList(const pandora::Cluster *const pCluster)
  {
	  pandora::OrderedCaloHitList orderedConnectedCaloHitList;

	  const pandora::OrderedCaloHitList &orderedCaloHitList = pCluster->GetOrderedCaloHitList();

	  pandora::CaloHitList caloHitList;
	  orderedCaloHitList.FillCaloHitList(caloHitList);

	  for(auto& pCaloHit : caloHitList)
	  {
		  const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(pCaloHit);
		  if(!APRILContentApi::HasAnyConnection(pAPRILCaloHit)) continue;

		  orderedConnectedCaloHitList.Add(pCaloHit);
	  }

	  return orderedConnectedCaloHitList;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::FitStart(const pandora::Cluster *const pCluster, const unsigned int maxOccupiedLayers, pandora::ClusterFitResult &clusterFitResult)
  {
      if (maxOccupiedLayers < 2)
          return pandora::STATUS_CODE_INVALID_PARAMETER;

	  const pandora::OrderedCaloHitList orderedCaloHitList = GetOrderedConnectedCaloHitList(pCluster);
      const unsigned int listSize(orderedCaloHitList.size());
  
      if (0 == listSize)
	  {
          return pandora::STATUS_CODE_NOT_INITIALIZED;
	  }
  
      if (listSize < 2)
          return pandora::STATUS_CODE_OUT_OF_RANGE;
  
      unsigned int occupiedLayerCount(0);
  
	  pandora::ClusterFitPointList clusterFitPointList;
      for (const pandora::OrderedCaloHitList::value_type &layerIter : orderedCaloHitList)
      {
          if (++occupiedLayerCount > maxOccupiedLayers)
              break;
  
          for (const pandora::CaloHit *const pCaloHit : *layerIter.second)
          {
              const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(pCaloHit);
			  if(!APRILContentApi::HasAnyConnection(pAPRILCaloHit)) continue;

              clusterFitPointList.push_back(pandora::ClusterFitPoint(pCaloHit));
          }
      }
  
      if(pandora::ClusterFitHelper::FitPoints(clusterFitPointList, clusterFitResult) != pandora::STATUS_CODE_SUCCESS)
		  return pandora::STATUS_CODE_FAILURE;

	  bool fitSuccessful = clusterFitResult.IsFitSuccessful() && clusterFitResult.GetDirection().GetMagnitude() > 0.
		  && clusterFitResult.GetIntercept().GetMagnitude() > 0.;

	  if(fitSuccessful)
		  return pandora::STATUS_CODE_SUCCESS;
	  else
		  return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::FitFullCluster(const pandora::Cluster *const pCluster, pandora::ClusterFitResult &clusterFitResult, bool useMainCluster, float eps)
  {
	  const pandora::OrderedCaloHitList orderedCaloHitList = GetOrderedConnectedCaloHitList(pCluster);
      const unsigned int listSize(orderedCaloHitList.size());
  
      if (0 == listSize)
	  {
          return pandora::STATUS_CODE_NOT_INITIALIZED;
	  }

      if (listSize < 2)
          return pandora::STATUS_CODE_OUT_OF_RANGE;
  
	  pandora::ClusterFitPointList clusterFitPointList;
	
	  if(useMainCluster)
	  {
		  pandora::CaloHitList mainClusterHits;
	      ClusterHelper::GetMainClusterHits(pCluster, mainClusterHits, eps);

	      for(auto& pCaloHit : mainClusterHits)
	      {
	          clusterFitPointList.push_back(pandora::ClusterFitPoint(pCaloHit));
	      }
	  }
	  else
	  {
		  for (const pandora::OrderedCaloHitList::value_type &layerIter : orderedCaloHitList)
          {
              for (const pandora::CaloHit *const pCaloHit : *layerIter.second)
              {
                  const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(pCaloHit);
	        	  if(!APRILContentApi::HasAnyConnection(pAPRILCaloHit)) continue;

                  clusterFitPointList.push_back(pandora::ClusterFitPoint(pCaloHit));
              }
          }
	  }

      if(pandora::ClusterFitHelper::FitPoints(clusterFitPointList, clusterFitResult) != pandora::STATUS_CODE_SUCCESS)
		  return pandora::STATUS_CODE_FAILURE;

	  bool fitSuccessful = clusterFitResult.GetDirection().GetMagnitude() > 0.
		  && clusterFitResult.GetIntercept().GetMagnitude() > 0.;

	  if(fitSuccessful)
		  return pandora::STATUS_CODE_SUCCESS;
	  else
		  return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::GetRMS(const pandora::CaloHitList& clusterHits, pandora::CartesianVector cog, pandora::CartesianVector axis,
		  float& rms1, float& rms2)
  {
	  TVector3 clusterAxis(axis.GetX(), axis.GetY(), axis.GetZ());

	  float theta = clusterAxis.Theta(); 
	  float phi = clusterAxis.Phi();

	  TRotation rotationMatrix;
	  rotationMatrix.RotateZ(-phi);
	  rotationMatrix.RotateY(-theta);
	  //rotationMatrix.RotateZ(phi);

	  TH2F hist2("hist2", "hist2", 100, -1000, 1000, 100, -1000, 1000);

	  TVector3 clusterCOG(cog.GetX(), cog.GetY(), cog.GetZ());

	  for(auto& clusterHit : clusterHits)
	  {
		  pandora::CartesianVector pos = clusterHit->GetPositionVector();
		  //std::cout << "   --- pos: " << pos.GetX() << ", " << pos.GetY() << ", " << pos.GetZ() << std::endl;
		  TVector3 hitPos(pos.GetX(), pos.GetY(), pos.GetZ());

		  TVector3 newHitPos = rotationMatrix * (hitPos - clusterCOG);
		  hist2.Fill(newHitPos.X(), newHitPos.Y());
	  }

	  //std::cout << "     --- RMS: " << hist2.GetRMS(1) << ", " << hist2.GetRMS(2) << std::endl;
	  rms1 = hist2.GetRMS(1);
	  rms2 = hist2.GetRMS(2);

	  return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::GetRMS(const pandora::Cluster *const pCluster, pandora::CartesianVector cog, pandora::CartesianVector axis,
		  float& rms1, float& rms2)
  {
	  const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetOrderedCaloHitList();
	  pandora::CaloHitList caloHitList;
	  orderedCaloHitList.FillCaloHitList(caloHitList);
  
	  GetRMS(caloHitList, cog, axis, rms1, rms2);

	  return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::GetMainClusterHits(const pandora::Cluster *const pCluster, pandora::CaloHitList& mainClusterHits, float eps)
  {
	  const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetOrderedCaloHitList();
	  pandora::CaloHitList caloHitList;
	  orderedCaloHitList.FillCaloHitList(caloHitList);

	  pandora::CaloHitVector caloHitVector;
	  caloHitVector.insert(caloHitVector.begin(), caloHitList.begin(), caloHitList.end());
	  std::vector<pandora::CaloHitVector> hitsForCluster;

	  CaloHitNeighborSearchHelper::ClusteringByDBSCAN(caloHitVector, hitsForCluster, eps, 2);

	  //std::cout << "  --- ClusteringInCluster size: " << hitsForCluster.size() << std::endl;

	  int maxHitVector = 0;
	  int maxHit = 0;

	  for(int i = 0; i < hitsForCluster.size(); ++i)
	  {
		  //std::cout << "    -> " << hitsForCluster.at(i).size() << std::endl;

		  if(maxHit < hitsForCluster.at(i).size())
		  {
			  maxHitVector = i;
			  maxHit = hitsForCluster.at(i).size();
		  }
	  }

	  if( (float)maxHit/caloHitVector.size() > 0.6 )
	  {
		  pandora::CaloHitList maxCaloHitList;

		  auto maxCaloHits = hitsForCluster.at(maxHitVector);

		  for(int i = 0; i < maxCaloHits.size(); ++i)
		  {
			  maxCaloHitList.push_back( maxCaloHits.at(i) );
		  }

		  mainClusterHits = maxCaloHitList;
	  }
	  else
	  {
		  mainClusterHits = caloHitList;
	  }

	  return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  float ClusterHelper::GetMeanHitPerLayer(const pandora::Cluster *const pCluster)
  {
	  const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetOrderedCaloHitList();

	  unsigned int layerHasHit = 0;
	  unsigned int totalHit = 0;

	  //std::cout << "     cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << std::endl;

	  for(auto& layer : orderedCaloHitList)
	  {
		  //std::cout << "        --- layer: " << layer.first << ", hit size: " << layer.second->size() << std::endl;

		  if(layer.second->size() > 0) 
		  {
			  ++layerHasHit;
			  totalHit += layer.second->size();
		  }
	  }

	  //std::cout << "     MeanHitPerLayer: " << (float)totalHit/layerHasHit << std::endl;

	  return (float)totalHit/layerHasHit;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  unsigned int ClusterHelper::GetClusterConnectorNumber(const pandora::Cluster *const pCluster)
  {
	  pandora::CaloHitList caloHitList;
	  const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetOrderedCaloHitList();
	  orderedCaloHitList.FillCaloHitList(caloHitList);

	  unsigned int nConnectors = 0;

	  for(auto& caloHit : caloHitList)
	  {
		  const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(caloHit));
		  const april_content::ConnectorList& forwardConnectorList = 
			  APRILContentApi::GetConnectorList(pCaloHit, april_content::FORWARD_DIRECTION);

		  nConnectors += forwardConnectorList.size();
	  }

	  return nConnectors;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::GetMainClusterHits(const pandora::Cluster *const pCluster, pandora::CaloHitList& mainClusterHits)
  {
	  const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetOrderedCaloHitList();
	  const pandora::CaloHitList& isolatedCaloHitList = pCluster->GetIsolatedCaloHitList();

	  pandora::CaloHitList caloHitList;
	  orderedCaloHitList.FillCaloHitList(caloHitList);
	  caloHitList.insert(caloHitList.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

	  pandora::CaloHitList connectedHits;

	  for(auto& caloHit : caloHitList)
	  {
		  const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(caloHit));
		  if(!APRILContentApi::HasAnyConnection(pCaloHit)) continue;

		  connectedHits.push_back(caloHit);
	  }
    
	  ////
	  bool allowSingleHitClusters = false;

	  pandora::CaloHitList seedCaloHitList;
	  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, 
			  CaloHitHelper::ExtractSeedCaloHitList(&connectedHits, seedCaloHitList, allowSingleHitClusters));

	  std::vector<pandora::CaloHitList> hitListVec;

	  for(auto& caloHit: seedCaloHitList)
	  {
		  const april_content::CaloHit *const seed(dynamic_cast<const april_content::CaloHit *const>(caloHit));

		  if(seed == nullptr) continue;
		  
          pandora::CaloHitList clusterCaloHitList;
          clusterCaloHitList.push_back(seed);

		  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, 
				  CaloHitHelper::BuildCaloHitList(seed, FORWARD_DIRECTION, clusterCaloHitList));

		  hitListVec.push_back(clusterCaloHitList);
	  }

	  ////
	  unsigned int totalHit = 0;

	  mainClusterHits.clear();

#if 0
	  std::cout << "       === GetMainClusterHit, cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() 
		  << ", hitListVec: " << hitListVec.size() << ", seedCaloHitList: " << seedCaloHitList.size() << std::endl;
#endif

	  for(unsigned int i = 0; i < hitListVec.size(); ++i)
	  {
		  auto& hitList = hitListVec.at(i);
		  totalHit += hitListVec.at(i).size();

		  for(auto& hit : hitList)
		  {
			  mainClusterHits.push_back(hit);
		  }
	  }

	  for(unsigned int i = 0; i < hitListVec.size(); ++i)
	  {
		  unsigned int hitsNum = hitListVec.at(i).size();

		  if(float(hitsNum)/totalHit > 0.55) 
		  {
			  mainClusterHits = hitListVec.at(i);
		  }
	  }
	  
	  return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  float ClusterHelper::GetHadronicEnergyInECAL(const pandora::Cluster *const pCluster)
  {
	  const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetOrderedCaloHitList();
	  const pandora::CaloHitList& isolatedCaloHitList = pCluster->GetIsolatedCaloHitList();

	  pandora::CaloHitList caloHitList;
	  orderedCaloHitList.FillCaloHitList(caloHitList);
	  caloHitList.insert(caloHitList.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

	  float hadronicEnergyInECAL = 0.;

	  for(auto iter = caloHitList.begin(); iter != caloHitList.end(); ++iter)
	  {
		  auto pCaloHit = *iter;
		  if(pCaloHit->GetHitType() == pandora::ECAL) hadronicEnergyInECAL += pCaloHit->GetHadronicEnergy();
	  }

	  return hadronicEnergyInECAL;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  float ClusterHelper::GetEnergyRatio(const pandora::OrderedCaloHitList& orderedCaloHitList)
  {
	  float energyRatio;
	  unsigned int nHits;

	  GetEnergyRatio(orderedCaloHitList, energyRatio, nHits);

	  return energyRatio;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode ClusterHelper::GetEnergyRatio(const pandora::OrderedCaloHitList& orderedCaloHitList, float& energyRatio, unsigned int& nHits)
  {
	  pandora::CaloHitList caloHitList;
	  orderedCaloHitList.FillCaloHitList(caloHitList);

	  float hadronicEnergyInECAL = 0.;
	  float totalEnergy = 0.;

	  nHits = 0;

	  for(auto iter = caloHitList.begin(); iter != caloHitList.end(); ++iter)
	  {
		  ++nHits;

		  auto pCaloHit = *iter;
		  float hitEnergy = pCaloHit->GetHadronicEnergy();

		  totalEnergy += hitEnergy;

		  if(pCaloHit->GetHitType() == pandora::ECAL) hadronicEnergyInECAL += hitEnergy;
	  }

	  energyRatio = hadronicEnergyInECAL/totalEnergy;
    
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  float ClusterHelper::GetElectromagneticEnergyInECAL(const pandora::Cluster *const pCluster)
  {
	  const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetOrderedCaloHitList();
	  const pandora::CaloHitList& isolatedCaloHitList = pCluster->GetIsolatedCaloHitList();

	  pandora::CaloHitList caloHitList;
	  orderedCaloHitList.FillCaloHitList(caloHitList);
	  caloHitList.insert(caloHitList.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

	  float emEnergyInECAL = 0.;

	  for(auto iter = caloHitList.begin(); iter != caloHitList.end(); ++iter)
	  {
		  auto pCaloHit = *iter;
		  if(pCaloHit->GetHitType() == pandora::ECAL) emEnergyInECAL += pCaloHit->GetElectromagneticEnergy();
	  }

	  return emEnergyInECAL;
  }
  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::Cluster *const pCluster, const pandora::CartesianVector &point,
      float &closestDistance, bool onlyUseConnectedHit)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

	const pandora::CaloHitList& isolatedCaloHitList = pCluster->GetIsolatedCaloHitList();
	clusterCaloHitList.insert(clusterCaloHitList.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));
	  if(onlyUseConnectedHit && !APRILContentApi::HasAnyConnection(pCaloHit)) continue;
      const float distance = (pCaloHit->GetPositionVector() - point).GetMagnitude();

      if(closestDistance > distance)
        closestDistance = distance;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::Cluster *const pCluster, const pandora::CartesianVector &point,
      float &closestDistance, pandora::CartesianVector& distanceVector, bool onlyUseConnectedHit)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

	const pandora::CaloHitList& isolatedCaloHitList = pCluster->GetIsolatedCaloHitList();
	clusterCaloHitList.insert(clusterCaloHitList.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));
	  if(onlyUseConnectedHit && !APRILContentApi::HasAnyConnection(pCaloHit)) continue;

	  pandora::CartesianVector dv = pCaloHit->GetPositionVector() - point;
      const float distance = dv.GetMagnitude();

      if(closestDistance > distance)
	  {
        closestDistance = distance;
		distanceVector = dv;
	  }
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::CaloHitList& caloHitList, const pandora::CartesianVector &point,
      float &closestDistance, bool onlyUseConnectedHit)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(caloHitList.empty())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    for(pandora::CaloHitList::const_iterator iter = caloHitList.begin() , endIter = caloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));
	  if(onlyUseConnectedHit && !APRILContentApi::HasAnyConnection(pCaloHit)) continue;
      const float distance = (pCaloHit->GetPositionVector() - point).GetMagnitude();

      if(closestDistance > distance)
        closestDistance = distance;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCentroidDistance(const pandora::Cluster *const pCluster, const pandora::CartesianVector &point,
      float &centroidDistance)
  {
    centroidDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CartesianVector clusterCentroid(0.f, 0.f, 0.f);
	// TODO:: centroid as input may save CPU time
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, clusterCentroid));

    centroidDistance = (clusterCentroid - point).GetMagnitude();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::Cluster *const pCluster1, const pandora::Cluster *const pCluster2,
      float &closestDistance, bool onlyUseConnectedHit)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster1 || NULL == pCluster2)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster1->GetNCaloHits() || 0 == pCluster2->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CaloHitList clusterCaloHitList1;
    pCluster1->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList1);

	const pandora::CaloHitList& isolatedCaloHitList = pCluster1->GetIsolatedCaloHitList();
	clusterCaloHitList1.insert(clusterCaloHitList1.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList1.begin() , endIter = clusterCaloHitList1.end() ;
        endIter != iter ; ++iter)
    {
      const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));
	  if(onlyUseConnectedHit && !APRILContentApi::HasAnyConnection(pCaloHit)) continue;

      float closestHitDistanceApproach(std::numeric_limits<float>::max());

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetClosestDistanceApproach(pCluster2,
          pCaloHit->GetPositionVector(), closestHitDistanceApproach, onlyUseConnectedHit));

      if(closestHitDistanceApproach < closestDistance)
        closestDistance = closestHitDistanceApproach;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  
  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::Cluster *const pCluster1, const pandora::Cluster *const pCluster2,
      float &closestDistance, pandora::CartesianVector& distanceVector, bool onlyUseConnectedHit)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(NULL == pCluster1 || NULL == pCluster2)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(0 == pCluster1->GetNCaloHits() || 0 == pCluster2->GetNCaloHits())
      return pandora::STATUS_CODE_FAILURE;

    pandora::CaloHitList clusterCaloHitList1;
    pCluster1->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList1);

	const pandora::CaloHitList& isolatedCaloHitList = pCluster1->GetIsolatedCaloHitList();
	clusterCaloHitList1.insert(clusterCaloHitList1.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList1.begin() , endIter = clusterCaloHitList1.end() ;
        endIter != iter ; ++iter)
    {
      const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));
	  if(onlyUseConnectedHit && !APRILContentApi::HasAnyConnection(pCaloHit)) continue;

      float closestHitDistanceApproach(std::numeric_limits<float>::max());

	  pandora::CartesianVector dv(0., 0., 0.);

#if 1
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetClosestDistanceApproach(pCluster2,
          pCaloHit->GetPositionVector(), closestHitDistanceApproach, dv, onlyUseConnectedHit));
#endif

      if(closestHitDistanceApproach < closestDistance)
	  {
        closestDistance = closestHitDistanceApproach;
		distanceVector = dv;
	  }
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClosestDistanceApproach(const pandora::CaloHitList& caloHitList1, 
			const pandora::CaloHitList& caloHitList2, float &closestDistance, bool onlyUseConnectedHit)
  {
    closestDistance = std::numeric_limits<float>::max();

    if(caloHitList1.empty() || caloHitList2.empty())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    for(pandora::CaloHitList::const_iterator iter = caloHitList1.begin() , endIter = caloHitList1.end() ;
        endIter != iter ; ++iter)
    {
      const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));
	  if(onlyUseConnectedHit && !APRILContentApi::HasAnyConnection(pCaloHit)) continue;

      float closestHitDistanceApproach(std::numeric_limits<float>::max());

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetClosestDistanceApproach(caloHitList2,
          pCaloHit->GetPositionVector(), closestHitDistanceApproach, onlyUseConnectedHit));

      if(closestHitDistanceApproach < closestDistance)
        closestDistance = closestHitDistanceApproach;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetNCaloHitSeeds(const pandora::Cluster *const pCluster, unsigned int &nSeeds)
  {
    if(NULL == pCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    pandora::CaloHitList clusterCaloHitList;
    pandora::CaloHitList seedsCaloHitList;

    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractSeedCaloHitList(&clusterCaloHitList, seedsCaloHitList));

    nSeeds = seedsCaloHitList.size();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  bool ClusterHelper::ContainsHitInOuterSamplingLayer(const pandora::Cluster *const pCluster)
  {
	  return (0 != pCluster->GetNHitsInOuterLayer());
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

   bool ClusterHelper::IsClusterLeavingDetector(const pandora::Cluster *const pCluster, const unsigned int nOuterLayersToExamine,
       const unsigned int nMipLikeOccupiedLayers, const unsigned int nShowerLikeOccupiedLayers, const float showerLikeEnergyInOuterLayers)
   {
       if (!ClusterHelper::ContainsHitInOuterSamplingLayer(pCluster))
           return false;
   
       if (ClusterHelper::ContainsHitType(pCluster, pandora::MUON))
           return true;
   
       // Examine occupancy and energy content of outer layers
       const unsigned int outerLayer(pCluster->GetOuterPseudoLayer());
       const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
   
       if (nOuterLayersToExamine > outerLayer)
           throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);
   
       unsigned int nOccupiedOuterLayers(0);
       float hadronicEnergyInOuterLayers(0.f);
   
       for (unsigned int iLayer = outerLayer - nOuterLayersToExamine; iLayer <= outerLayer; ++iLayer)
       {   
   		pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.find(iLayer);
   
           if (orderedCaloHitList.end() != iter)
           {
               nOccupiedOuterLayers++;
   
               for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end(); hitIter != hitIterEnd; ++hitIter)
               {
                   hadronicEnergyInOuterLayers += (*hitIter)->GetHadronicEnergy();
               }   
           }   
       }   
   
       if ((nOccupiedOuterLayers >= nMipLikeOccupiedLayers) ||
           ((nOccupiedOuterLayers == nShowerLikeOccupiedLayers) && (hadronicEnergyInOuterLayers > showerLikeEnergyInOuterLayers)))
       {   
           return true;
       }   
       
       return false;
   }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::IsClusterLeavingDetector(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, unsigned int nOuterLayersToExamine,
      float maxDistanceToDetectorEdge, unsigned int minNHitsNearEdges)
  {
    if(NULL == pCluster)
      throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    // muons escape detector
    if( abs(pCluster->GetParticleId()) == 13 || ClusterHelper::ContainsHitType(pCluster, pandora::MUON))
      return true;

    if(pandora::HCAL != pCluster->GetOuterLayerHitType())
      return false;

    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
    const unsigned int outerPseudoLayer(pCluster->GetOuterPseudoLayer());
    const unsigned int innerPseudoLayer(pCluster->GetInnerPseudoLayer());
    const unsigned int nPseudoLayers(outerPseudoLayer-innerPseudoLayer+1);
    const unsigned int pseudoLayerStart(nPseudoLayers < nOuterLayersToExamine ? innerPseudoLayer : outerPseudoLayer-nOuterLayersToExamine);

    const pandora::GeometryManager *const pGeometry = pandora.GetGeometry();

    const pandora::SubDetector &hcalEndcap(pGeometry->GetSubDetector(pandora::HCAL_ENDCAP));
    const pandora::SubDetector &hcalBarrel(pGeometry->GetSubDetector(pandora::HCAL_BARREL));

    const float hcalEndcapOuterZCoordinate(hcalEndcap.GetOuterZCoordinate());
    const float hcalEndcapOuterRCoordinate(hcalEndcap.GetOuterRCoordinate());
    const float hcalBarrelOuterRCoordinate(hcalBarrel.GetOuterRCoordinate());

    unsigned int nHitsNearbyEdge(0);

    for(unsigned int pl=pseudoLayerStart ; pl<outerPseudoLayer ; ++pl)
    {
      pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.find(pl);

      if(orderedCaloHitList.end() == iter)
        continue;

      for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end() ;
          hitIter != hitIterEnd; ++hitIter)
      {
        const pandora::CaloHit *const pCaloHit(*hitIter);

        if(pandora::HCAL != pCaloHit->GetHitType())
          continue;

        if(pandora::ENDCAP == pCaloHit->GetHitRegion())
        {
          pandora::CartesianVector outerNormaleVector(0.f, 0.f, 0.f);

          if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetOuterNormaleVector(pandora, pandora::HCAL_ENDCAP, (*hitIter)->GetPositionVector(), outerNormaleVector))
            continue;

          const float hitCosAngleNormale(outerNormaleVector.GetCosOpeningAngle(pCaloHit->GetPositionVector()));
          const float hitDistanceToOrigin(pCaloHit->GetPositionVector().GetMagnitude());
          const float hitDistanceToREdge(hcalEndcapOuterRCoordinate - hitDistanceToOrigin*hitCosAngleNormale);
          const float hitDistanceToZEdge(hcalEndcapOuterZCoordinate-fabs(pCaloHit->GetPositionVector().GetZ()));

          if(hitDistanceToREdge < maxDistanceToDetectorEdge)
            ++nHitsNearbyEdge;
          else if(hitDistanceToZEdge < maxDistanceToDetectorEdge)
            ++nHitsNearbyEdge;
        }
        else if(pandora::BARREL == pCaloHit->GetHitRegion())
        {
          pandora::CartesianVector outerNormaleVector(0.f, 0.f, 0.f);

          if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetOuterNormaleVector(pandora, pandora::HCAL_BARREL, (*hitIter)->GetPositionVector(), outerNormaleVector))
            continue;

          const float hitCosAngleNormale(outerNormaleVector.GetCosOpeningAngle(pCaloHit->GetPositionVector()));
          const float hitDistanceToOrigin(pCaloHit->GetPositionVector().GetMagnitude());
          const float hitDistanceToEdge(hcalBarrelOuterRCoordinate - hitDistanceToOrigin*hitCosAngleNormale);

          if(hitDistanceToEdge < maxDistanceToDetectorEdge)
            ++nHitsNearbyEdge;
        }
      }
    }

    if(nHitsNearbyEdge >= minNHitsNearEdges)
      return true;

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::ContainsHitType(const pandora::Cluster *const pCluster, const pandora::HitType hitType)
  {
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for (pandora::OrderedCaloHitList::const_reverse_iterator iter = orderedCaloHitList.rbegin(), iterEnd = orderedCaloHitList.rend(); iter != iterEnd; ++iter)
    {
      for (pandora::CaloHitList::const_iterator hIter = iter->second->begin(), hIterEnd = iter->second->end(); hIter != hIterEnd; ++hIter)
      {
        const pandora::CaloHit *const pCaloHit(*hIter);

        if (hitType == pCaloHit->GetHitType())
          return true;
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetMeanSurroundingEnergy(const pandora::Cluster *const pCluster, float &meanSurroundingEnergy)
  {
    if(NULL == pCluster || 0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    meanSurroundingEnergy = 0.f;

    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for (pandora::OrderedCaloHitList::const_reverse_iterator iter = orderedCaloHitList.rbegin(), iterEnd = orderedCaloHitList.rend(); iter != iterEnd; ++iter)
    {
      for (pandora::CaloHitList::const_iterator hIter = iter->second->begin(), hIterEnd = iter->second->end(); hIter != hIterEnd; ++hIter)
      {
        const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*hIter));

        if(NULL == pCaloHit)
          return pandora::STATUS_CODE_INVALID_PARAMETER;

        meanSurroundingEnergy += pCaloHit->GetSurroundingEnergy();
      }
    }

    meanSurroundingEnergy /= pCluster->GetNCaloHits();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetClusterVolume(const pandora::Cluster *const pCluster, float& clusterVolume)
  {
    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

    float clusterEnergy(0.);

	clusterVolume = 0.;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      float hitEnergy(0.);

      if(pCaloHit->GetHitType() == pandora::ECAL)
      {
        hitEnergy = pCaloHit->GetElectromagneticEnergy();
      }
	  else
      {
        hitEnergy = pCaloHit->GetHadronicEnergy();
      }

	  clusterEnergy += hitEnergy;

	  pandora::CartesianVector hitPosition = pCaloHit->GetPositionVector();
	  pandora::CartesianVector relativePosition = hitPosition - centroid;

      float deltaVol = hitEnergy * relativePosition.GetMagnitude();
      clusterVolume += deltaVol;
    }

	// FIXME:: clusterEnergy should not be zero
	if(clusterEnergy < 0.0001) 
	{
		clusterVolume = 0.;
	}
	else
	{
		clusterVolume = clusterVolume/clusterEnergy;
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::HitRegion ClusterHelper::GetRegion(const pandora::Cluster *const pCluster)
  {
	  std::vector<pandora::HitRegion> hitRegion;

      pandora::CaloHitList clusterCaloHitList;
      pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);
	  pandora::CaloHitList isoCaloHitList = pCluster->GetIsolatedCaloHitList();
	  clusterCaloHitList.insert(clusterCaloHitList.begin(), isoCaloHitList.begin(), isoCaloHitList.end());

	  for(auto& caloHit : clusterCaloHitList)
	  {
		  hitRegion.push_back(caloHit->GetHitRegion());
	  }

	  pandora::HitRegion region = pandora::HitRegion::SINGLE_REGION;

	  int maxCountRegion = 0;


	  for (int regionInt = pandora::HitRegion::BARREL; regionInt <= pandora::HitRegion::SINGLE_REGION; ++regionInt)
	  {
		  int countRegion = std::count(hitRegion.begin(), hitRegion.end(), regionInt);

		  if(countRegion > maxCountRegion)
		  {
			  maxCountRegion = countRegion;
			  region = static_cast<pandora::HitRegion>(regionInt);
		  }
	  }

	  return region;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ClusterHelper::GetMeanDensity(const pandora::Cluster *const pCluster)
  {
	  float density = 0.;

	  GetMeanDensity(pCluster, density);
	  return density;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetMeanDensity(const pandora::Cluster *const pCluster, float &meanDensity)
  {
    if(nullptr == pCluster || 0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    meanDensity = 0.;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);
	pandora::CaloHitList isoCaloHitList = pCluster->GetIsolatedCaloHitList();
	clusterCaloHitList.insert(clusterCaloHitList.begin(), isoCaloHitList.begin(), isoCaloHitList.end());

	for(auto& caloHit : clusterCaloHitList)
    {
        const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(caloHit));

        if(nullptr == pCaloHit)
		{
		  std::cout << "--- ClusterHelper::GetMeanDensity error: calo hit nullptr" << std::endl;
		  continue;
          //return pandora::STATUS_CODE_INVALID_PARAMETER;
		}

        meanDensity += pCaloHit->GetDensity();
    }

    meanDensity /= pCluster->GetNCaloHits();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetChiClusterMerging(const pandora::Pandora &pandora, const pandora::Cluster *const pClusterToEnlarge, const pandora::Cluster *const pClusterToMerge, float& trackEnergy, float &oldChi, float &newChi)
  {
    const pandora::TrackList trackList(pClusterToEnlarge->GetAssociatedTrackList());

    pandora::TrackList trackListCombined(pClusterToMerge->GetAssociatedTrackList());
    trackListCombined.insert(trackListCombined.begin(), trackList.begin(), trackList.end());

    if(trackList.empty())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

#if 0
    float trackEnergySum(0.f);
    float trackEnergySumCombined(0.f);

    for (pandora::TrackList::const_iterator trackIter = trackList.begin(), trackIterEnd = trackList.end(); trackIter != trackIterEnd; ++trackIter)
      trackEnergySum += (*trackIter)->GetEnergyAtDca();

    for (pandora::TrackList::const_iterator trackIter = trackListCombined.begin(), trackIterEnd = trackListCombined.end(); trackIter != trackIterEnd; ++trackIter)
      trackEnergySumCombined += (*trackIter)->GetEnergyAtDca();

    const float clusterEnergy(pClusterToEnlarge->GetTrackComparisonEnergy(pandora));
    const float clusterEnergyCombined(clusterEnergy + pClusterToMerge->GetTrackComparisonEnergy(pandora));

    oldChi = ReclusterHelper::GetTrackClusterCompatibility(pandora, clusterEnergy, trackEnergySum);
    newChi = ReclusterHelper::GetTrackClusterCompatibility(pandora, clusterEnergyCombined, trackEnergySumCombined);
#endif

    oldChi = ReclusterHelper::GetTrackClusterCompatibility(pandora, pClusterToEnlarge, trackList);
    newChi = ReclusterHelper::GetTrackClusterCompatibility(pandora, pClusterToEnlarge, pClusterToMerge, trackListCombined);

    trackEnergy = 0.;

    for (auto track : trackListCombined)
	{
		trackEnergy += track->GetEnergyAtDca();
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::MergeClusters(const pandora::Algorithm &algorithm, ClusterToClusterMap &clusterToClusterMap)
  {
    for(ClusterToClusterMap::iterator iter = clusterToClusterMap.begin(), endIter = clusterToClusterMap.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Cluster *const pDaughterCluster(iter->first);
      const pandora::Cluster *const pParentCluster(iter->second);

      if((NULL == pDaughterCluster) || (NULL == pParentCluster))
        continue;

      for(ClusterToClusterMap::iterator jter = clusterToClusterMap.begin(), endJter = clusterToClusterMap.end() ;
          endJter != jter ; ++jter)
      {
        if(jter->first == pDaughterCluster)
          continue;

        if(jter->second == pDaughterCluster)
          jter->second = pParentCluster;
      }

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(algorithm, pParentCluster, pDaughterCluster));

      (iter->second) = NULL;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetTrackClusterDistance(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const pandora::Track *const pTrack, const float maxTransverseDistance, float &trackClusterDistance)
  {
    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    const float bField(pandora.GetPlugins()->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));
    const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
        pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

    const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());

    unsigned int nNearbyCaloHits(0);
    float distanceToHelix(0.f);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      const float trackHitAngle(pCaloHit->GetPositionVector().GetOpeningAngle(trackProjection));

      // cut needed for discriminate track opposite direction
      if(trackHitAngle > (2*M_PI)/3.f)
        continue;

	  pandora::CartesianVector thDistance(0., 0., 0.);
	  float genericTime = 0.;

	  if(pandora::STATUS_CODE_SUCCESS != helix.GetDistanceToPoint(pCaloHit->GetPositionVector(), thDistance, genericTime))
	  	continue;

	  const float hitDistanceToHelix = thDistance.GetMagnitude();

      if(hitDistanceToHelix < maxTransverseDistance)
      {
        ++nNearbyCaloHits;
        distanceToHelix += hitDistanceToHelix;
      }
    }

    if(0 == nNearbyCaloHits)
      return pandora::STATUS_CODE_NOT_FOUND;

    trackClusterDistance = distanceToHelix / nNearbyCaloHits;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ClusterHelper::GetAverageTime(const pandora::Cluster *const pCluster, bool onlyForECALHit)
  {
	  pandora::CaloHitList clusterCaloHitList;
	  pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

	  float averageTime = 0.;
	  float totalEnergy = 0.;

	  for(auto hitIter = clusterCaloHitList.begin(); hitIter != clusterCaloHitList.end(); ++hitIter)
	  {
	  	auto pCaloHit = *hitIter;

		if(onlyForECALHit)
		{
			if(pCaloHit->GetHitType() != pandora::ECAL) continue;
		}

		float hitTime = pCaloHit->GetTime();

		if(hitTime<1.e-2) continue;

		float hitEnergy = pCaloHit->GetHadronicEnergy();

		averageTime += hitTime * hitEnergy;
		totalEnergy += hitEnergy;
	  }

	  averageTime = averageTime / totalEnergy;

	  return averageTime;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::DoesClusterCrossGapRegion(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const unsigned int startLayer,
      const unsigned int endLayer, const pandora::DetectorGap *&pDetectorGap, const unsigned int nSamplingPoints)
  {
    const unsigned int fitStartLayer(std::max(startLayer, pCluster->GetInnerPseudoLayer()));
    const unsigned int fitEndLayer(std::min(endLayer, pCluster->GetOuterPseudoLayer()));

    if (fitStartLayer > fitEndLayer)
      throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    pandora::ClusterFitResult fitResult;
    if (pandora::STATUS_CODE_SUCCESS != pandora::ClusterFitHelper::FitLayers(pCluster, fitStartLayer, fitEndLayer, fitResult))
      return false;

    const pandora::CartesianVector startLayerCentroid(pCluster->GetCentroid(fitStartLayer));
    const float propagationDistance((pCluster->GetCentroid(fitEndLayer) - startLayerCentroid).GetDotProduct(fitResult.GetDirection()));

    return ClusterHelper::DoesFitCrossGapRegion(pandora, fitResult, startLayerCentroid, propagationDistance, pDetectorGap, nSamplingPoints);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool ClusterHelper::DoesFitCrossGapRegion(const pandora::Pandora &pandora, const pandora::ClusterFitResult &clusterFitResult,
      const pandora::CartesianVector &startPosition, const float propagationDistance, const pandora::DetectorGap *&pDetectorGap, const unsigned int nSamplingPoints)
  {
    const pandora::CartesianVector &fitDirection(clusterFitResult.GetDirection());
    const pandora::CartesianVector &fitIntercept(clusterFitResult.GetIntercept());

    const float fitStartDistance((startPosition - fitIntercept).GetDotProduct(fitDirection));
    const pandora::CartesianVector fitStartPosition(fitIntercept + (fitDirection * fitStartDistance));
    const pandora::CartesianVector fitPropagation(fitDirection * propagationDistance);

    const pandora::DetectorGapList &detectorGapList(pandora.GetGeometry()->GetDetectorGapList());

    for (unsigned int i = 0; i < nSamplingPoints; ++i)
    {
      const pandora::CartesianVector fitPosition(fitStartPosition + (fitPropagation * (static_cast<float>(i) / static_cast<float>(nSamplingPoints))));

      for (pandora::DetectorGapList::const_iterator iter = detectorGapList.begin(), iterEnd = detectorGapList.end(); iter != iterEnd; ++iter)
      {
        // ATTN Could pass (e.g. inner layer) hit type for cluster, but know that actually need to pass only any 3D hit type (hack)
        if ((*iter)->IsInGap(fitPosition, pandora::ECAL))
        {
          pDetectorGap = *iter;
          return true;
        }
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetDistanceToDetectorGap(const pandora::CartesianVector &positionVector, const pandora::DetectorGap *const pDetectorGap, float &distanceToGap)
  {
    distanceToGap = 0.f;

    if(NULL == pDetectorGap)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(pDetectorGap->IsInGap(positionVector, pandora::ECAL))
      return pandora::STATUS_CODE_FAILURE;

    const pandora::BoxGap *const pBoxGap(dynamic_cast<const pandora::BoxGap *const>(pDetectorGap));

    if(pBoxGap)
    {
      const pandora::CartesianVector relativePosition(positionVector - pBoxGap->GetVertex());

      const float projection1(relativePosition.GetDotProduct(pBoxGap->GetSide1().GetUnitVector()));
      const float projection2(relativePosition.GetDotProduct(pBoxGap->GetSide2().GetUnitVector()));
      const float projection3(relativePosition.GetDotProduct(pBoxGap->GetSide3().GetUnitVector()));

      distanceToGap = std::min(fabs(projection1), std::min(fabs(projection2), fabs(projection3)));

      return pandora::STATUS_CODE_SUCCESS;
    }

    const pandora::ConcentricGap *const pConcentricGap(dynamic_cast<const pandora::ConcentricGap *const>(pDetectorGap));

    if(pConcentricGap)
    {
      const float z(positionVector.GetZ());
      const float x(positionVector.GetX()), y(positionVector.GetY());
      const float r(std::sqrt(x * x + y * y));
      bool inner(false), outer(false);
      const bool inZ(pConcentricGap->GetMaxZCoordinate() < z && pConcentricGap->GetMinZCoordinate() > z);
      float zDistance(0.f), rInnerDistance(0.f), rOuterDistance(0.f);

      if(pConcentricGap->GetMaxZCoordinate() < z)
      {
        zDistance = fabs(z - pConcentricGap->GetMaxZCoordinate());
      }

      if(pConcentricGap->GetMinZCoordinate() > z)
      {
        zDistance = fabs(z - pConcentricGap->GetMinZCoordinate());
      }

      // inner r case
      for(unsigned int i=0 ; i<pConcentricGap->GetInnerSymmetryOrder()+1 ; i++)
      {
        const float phi = pConcentricGap->GetInnerPhiCoordinate() + 2 * M_PI * (static_cast<float>(i) / static_cast<float>(pConcentricGap->GetInnerSymmetryOrder()));
        const float phiMin = phi - (2 * M_PI / static_cast<float>(pConcentricGap->GetInnerSymmetryOrder())) / 2.f;
        const float phiMax = phi + (2 * M_PI / static_cast<float>(pConcentricGap->GetInnerSymmetryOrder())) / 2.f;
        const float phiPosition(std::atan2(y, x));

        if(phiPosition > phiMin && phiPosition < phiMax)
        {
          const pandora::CartesianVector normaleVector(std::cos(phi), std::sin(phi), 0.f);

          if(r*std::cos(normaleVector.GetOpeningAngle(positionVector)) < pConcentricGap->GetInnerRCoordinate())
          {
            rInnerDistance = fabs(pConcentricGap->GetInnerRCoordinate() - r*std::cos(normaleVector.GetOpeningAngle(positionVector)));
            inner = true;
          }

          break;
        }
      }

      // outer r case
      for(unsigned int i=0 ; i<pConcentricGap->GetOuterSymmetryOrder()+1 ; i++)
      {
        const float phi = pConcentricGap->GetOuterPhiCoordinate() + 2 * M_PI * (static_cast<float>(i) / static_cast<float>(pConcentricGap->GetOuterSymmetryOrder()));
        const float phiMin = phi - (2 * M_PI / static_cast<float>(pConcentricGap->GetOuterSymmetryOrder())) / 2.f;
        const float phiMax = phi + (2 * M_PI / static_cast<float>(pConcentricGap->GetOuterSymmetryOrder())) / 2.f;
        const float phiPosition(std::atan2(y, x));

        if(phiPosition > phiMin && phiPosition < phiMax)
        {
          const pandora::CartesianVector normaleVector(std::cos(phi), std::sin(phi), 0.f);

          if(r*std::cos(normaleVector.GetOpeningAngle(positionVector)) > pConcentricGap->GetOuterRCoordinate())
          {
            rOuterDistance = fabs(r*std::cos(normaleVector.GetOpeningAngle(positionVector)) - pConcentricGap->GetOuterRCoordinate());
            outer = true;
          }

          break;
        }
      }

      if(!inner && !outer)
      {
        distanceToGap = fabs(zDistance);
      }
      else if(inZ)
      {
        if(inner)
          distanceToGap = fabs(rInnerDistance);
        else
          distanceToGap = fabs(rOuterDistance);
      }
      else
      {
        float rDistance(inner ? rInnerDistance : rOuterDistance);
        distanceToGap = std::sqrt(fabs(rDistance)*fabs(rDistance) + fabs(zDistance)*fabs(zDistance));
      }

      return pandora::STATUS_CODE_SUCCESS;
    }

    return pandora::STATUS_CODE_FAILURE;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCaloHitsNearDetectorGaps(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const float maxDistanceFine,
      const float maxDistanceCoarse, pandora::CaloHitList &caloHitList, bool shouldUseIsolatedHits)
  {
    const pandora::DetectorGapList &detectorGapList(pandora.GetGeometry()->GetDetectorGapList());

    for (pandora::DetectorGapList::const_iterator iter = detectorGapList.begin(), iterEnd = detectorGapList.end(); iter != iterEnd; ++iter)
    {
      const pandora::DetectorGap *const pDetectorGap(*iter);
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCaloHitsNearDetectorGap(pandora, pCluster, pDetectorGap, maxDistanceFine, maxDistanceCoarse, caloHitList, shouldUseIsolatedHits));
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::GetCaloHitsNearDetectorGap(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const pandora::DetectorGap *const pDetectorGap,
      const float maxDistanceFine, const float maxDistanceCoarse, pandora::CaloHitList &caloHitList, bool shouldUseIsolatedHits)
  {
    if(0 == pCluster->GetNCaloHits())
      return pandora::STATUS_CODE_SUCCESS;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(!shouldUseIsolatedHits && pCaloHit->IsIsolated())
        continue;

      const pandora::Granularity &granularity(pandora.GetGeometry()->GetHitTypeGranularity(pCaloHit->GetHitType()));
      const float maxDistance(granularity <= pandora::FINE ? maxDistanceFine : maxDistanceCoarse);
      float distanceToGap(0.f);

      if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetDistanceToDetectorGap(pCaloHit->GetPositionVector(), pDetectorGap, distanceToGap))
        continue;

      if(distanceToGap < maxDistance)
        caloHitList.push_back(pCaloHit);
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::CleanAndDeleteCluster(const pandora::Algorithm &algorithm, const pandora::Cluster *const pCluster)
  {
    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin() , endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));

      if(NULL == pCaloHit)
        continue;

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::RemoveAndDeleteAllConnections(pCaloHit));
    }

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(algorithm, pCluster));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterHelper::CleanAndDeleteClusters(const pandora::Algorithm &algorithm, const pandora::ClusterList &clusterList)
  {
    for(pandora::ClusterList::const_iterator iter = clusterList.begin(), endIter = clusterList.end() ;
        endIter != iter ; ++iter)
    {
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::CleanAndDeleteCluster(algorithm, *iter));
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

} 
