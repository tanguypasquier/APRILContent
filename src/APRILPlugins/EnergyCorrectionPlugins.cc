/// \file EnergyCorrectionPlugins.cc
/*
 *
 * EnergyCorrectionPlugin.cc source template automatically generated by a class generator
 * Creation date : mar. nov. 17 2015
 * Updated november 2023 by Tanguy Pasquier
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */
#include <fstream>
#include "APRILPlugins/EnergyCorrectionPlugins.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILPlugins/ParticleIdPlugins.h"

#include "Pandora/AlgorithmHeaders.h"

namespace april_content
{
  AnalogicEnergyFunction::AnalogicEnergyFunction() :
        m_ecalEnergyType(0),
        m_hcalEnergyType(0),
        m_muonEnergyType(0),
        m_otherEnergyType(0)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode AnalogicEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    correctedEnergy = 0.f;

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;

      const pandora::HitType hitType(pCaloHit->GetHitType());

      const unsigned int energyType(
          (hitType == pandora::ECAL) ? m_ecalEnergyType :
              (hitType == pandora::HCAL) ? m_hcalEnergyType :
                  (hitType == pandora::MUON) ? m_muonEnergyType :
                      m_otherEnergyType);

      switch(energyType)
      {
      case 0:
        correctedEnergy += pCaloHit->GetInputEnergy();
        break;
      case 1:
        correctedEnergy += pCaloHit->GetElectromagneticEnergy();
        break;
      case 2:
        correctedEnergy += pCaloHit->GetHadronicEnergy();
        break;
      default:
        correctedEnergy += pCaloHit->GetInputEnergy();
        break;
      }
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode AnalogicEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_ecalEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalEnergyType", m_ecalEnergyType));

    m_hcalEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalEnergyType", m_hcalEnergyType));

    m_muonEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MuonEnergyType", m_muonEnergyType));

    m_otherEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OtherEnergyType", m_otherEnergyType));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  SdhcalQuadraticEnergyFunction::SdhcalQuadraticEnergyFunction()
  {
    m_energyConstantParameters.push_back(0.0385315);
    m_energyConstantParameters.push_back(4.22584e-05);
    m_energyConstantParameters.push_back(-7.54657e-09);
    m_energyConstantParameters.push_back(0.0784297);
    m_energyConstantParameters.push_back(-5.69439e-05);
    m_energyConstantParameters.push_back(-4.95924e-08);
    m_energyConstantParameters.push_back(0.127212);
    m_energyConstantParameters.push_back(4.56414e-05);
    m_energyConstantParameters.push_back(1.41142e-08);

    m_sdhcalThresholds.push_back(1);
    m_sdhcalThresholds.push_back(2);
    m_sdhcalThresholds.push_back(3);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode SdhcalQuadraticEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    unsigned int NHadronicHit  = 0;
    unsigned int NHadronicHit1 = 0;
    unsigned int NHadronicHit2 = 0;
    unsigned int NHadronicHit3 = 0;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    float emEnergy = 0.f;
    float otherEnergy = 0.f;

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;

      // Ecal case. Get the calibrated hit energy
      if(pandora::ECAL == pCaloHit->GetHitType())
      {
        emEnergy += pCaloHit->GetElectromagneticEnergy();
        continue;
      }
      // SDHCAL case. Do thresholds counting
      else if(pandora::HCAL == pCaloHit->GetHitType())
      {
        if(fabs(m_sdhcalThresholds.at(0) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit1++;
        else if(fabs(m_sdhcalThresholds.at(1) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit2++;
        else if(fabs(m_sdhcalThresholds.at(2) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit3++;
        else
        {
          otherEnergy += pCaloHit->GetInputEnergy();
          continue;
        }

        NHadronicHit++;
      }
      // Other hit types ... should never happen
      else
      {
        otherEnergy += pCaloHit->GetInputEnergy();
      }
    }

    // estimate of sdhcal energy
    const float alpha(m_energyConstantParameters.at(0) + m_energyConstantParameters.at(1)*NHadronicHit + m_energyConstantParameters.at(2)*NHadronicHit*NHadronicHit);
    const float beta(m_energyConstantParameters.at(3) + m_energyConstantParameters.at(4)*NHadronicHit + m_energyConstantParameters.at(5)*NHadronicHit*NHadronicHit);
    const float gamma(m_energyConstantParameters.at(6) + m_energyConstantParameters.at(7)*NHadronicHit + m_energyConstantParameters.at(8)*NHadronicHit*NHadronicHit);
    const float hadEnergy(NHadronicHit1*alpha + NHadronicHit2*beta + NHadronicHit3*gamma);

    correctedEnergy = emEnergy + hadEnergy + otherEnergy;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode SdhcalQuadraticEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    pandora::FloatVector energyConstantParameters;
    pandora::StatusCode statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "EnergyConstantParameters", energyConstantParameters);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_energyConstantParameters = energyConstantParameters;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(9 != m_energyConstantParameters.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    pandora::FloatVector sdhcalThresholds;
    statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "SdhcalThresholds", sdhcalThresholds);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_sdhcalThresholds = sdhcalThresholds;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(3 != m_sdhcalThresholds.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  BarrelGapEnergyFunction::BarrelGapEnergyFunction() :
        m_ecalDistanceToGap(10.f),  // 8 mm + 2 mm
        m_hcalDistanceToGap(30.f),  // 20 mm + 10 mm
        m_ecalGapAlpha(0),
        m_ecalGapBeta(0),
        m_hcalGapAlpha(1.5254),
        m_hcalGapBeta(0)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode BarrelGapEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
	  //std::cout << "BarrelGapEnergyFunction::MakeEnergyCorrections" << std::endl;
    if(m_ecalZGapPositions.empty() && m_hcalZGapPositions.empty())
      return pandora::STATUS_CODE_SUCCESS;

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_SUCCESS;

    float ecalGapEnergy(0), hcalGapEnergy(0);

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);
      const bool nearbyGap(this->IsNearbyGap(pCaloHit));

      if(!nearbyGap)
        continue;

      if(pCaloHit->GetHitType() == pandora::ECAL)
        ecalGapEnergy += pCaloHit->GetHadronicEnergy();
      else if(pCaloHit->GetHitType() == pandora::HCAL)
        hcalGapEnergy += pCaloHit->GetHadronicEnergy();
    }

    correctedEnergy +=
        m_ecalGapAlpha * ecalGapEnergy + m_ecalGapBeta * ecalGapEnergy * ecalGapEnergy +
        m_hcalGapAlpha * hcalGapEnergy + m_hcalGapBeta * hcalGapEnergy * hcalGapEnergy;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool BarrelGapEnergyFunction::IsNearbyGap(const pandora::CaloHit *const pCaloHit) const
  {
    if(pCaloHit->GetHitRegion() != pandora::BARREL)
      return false;

    if(pCaloHit->GetHitType() != pandora::ECAL && pCaloHit->GetHitType() != pandora::HCAL)
      return false;

    const pandora::FloatVector zGapPositions(pCaloHit->GetHitType() == pandora::ECAL ? m_ecalZGapPositions : m_hcalZGapPositions);
    const float distanceToGap(pCaloHit->GetHitType() == pandora::ECAL ? m_ecalDistanceToGap : m_hcalDistanceToGap);
    const float hitZ(pCaloHit->GetPositionVector().GetZ());

    for(pandora::FloatVector::const_iterator iter = zGapPositions.begin(), endIter = zGapPositions.end() ;
        endIter != iter ; ++iter)
    {
      const float gapZPosition(*iter);

      if( ((hitZ < gapZPosition) && (hitZ > gapZPosition-distanceToGap))
       || ((hitZ > gapZPosition) && (hitZ < gapZPosition+distanceToGap)) )
      {
        return true;
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode BarrelGapEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "EcalZGapPositions", m_ecalZGapPositions));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "HcalZGapPositions", m_hcalZGapPositions));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalDistanceToGap", m_ecalDistanceToGap));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalDistanceToGap", m_hcalDistanceToGap));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalGapAlpha", m_ecalGapAlpha));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalGapBeta", m_ecalGapBeta));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalGapAlpha", m_hcalGapAlpha));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalGapBeta", m_hcalGapBeta));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  ThetaNHitFunction::ThetaNHitFunction() :
       m_lowEnergyCut(3.f)
  {
        m_sdhcalThresholds.push_back(1);
        m_sdhcalThresholds.push_back(2);
        m_sdhcalThresholds.push_back(3);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ThetaNHitFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    //unsigned int NHadronicHit = 0;
    unsigned int NHadronicHit1 = 0;
    unsigned int NHadronicHit2 = 0;
    unsigned int NHadronicHit3 = 0;
  
    unsigned int barrelNHadronicHit1 = 0;
    unsigned int barrelNHadronicHit2 = 0;
    unsigned int barrelNHadronicHit3 = 0;

    unsigned int endcapNHadronicHit1 = 0;
    unsigned int endcapNHadronicHit2 = 0; 
    unsigned int endcapNHadronicHit3 = 0; 

    float initialHadronic = 0;

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_SUCCESS;

    if(correctedEnergy < m_lowEnergyCut)
      return pandora::STATUS_CODE_SUCCESS;

    unsigned int startingPseudoLayer(std::numeric_limits<unsigned int>::max());
 
    const pandora::StatusCode statusCode(ParticleIdHelper::GetStartingPseudoLayer(this->GetPandora(), pCluster, ParticleIdHelper::StartingLayerSettings(), startingPseudoLayer));

    // do not apply energy corrections if starting layer not found
    if(pandora::STATUS_CODE_SUCCESS != statusCode)
      return pandora::STATUS_CODE_SUCCESS;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    bool noShowerHit(true);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(pCaloHit->GetHitType() == pandora::HCAL)
        {
          if(pCaloHit->GetHitRegion() == pandora::BARREL)
          {
            if(fabs(m_sdhcalThresholds.at(0) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            {
              barrelNHadronicHit1++;
              initialHadronic+=pCaloHit->GetInputEnergy();
            }
            else if(fabs(m_sdhcalThresholds.at(1) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            {
              barrelNHadronicHit2++;
              initialHadronic+=pCaloHit->GetInputEnergy();
            }
            else if(fabs(m_sdhcalThresholds.at(2) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            {
              barrelNHadronicHit3++;
              initialHadronic+=pCaloHit->GetInputEnergy();
            }
          }
          else if(pCaloHit->GetHitRegion() == pandora::ENDCAP)
          {
            if(fabs(m_sdhcalThresholds.at(0) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            { 
              endcapNHadronicHit1++;
              initialHadronic+=pCaloHit->GetInputEnergy();
            }
            else if(fabs(m_sdhcalThresholds.at(1) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            {
              endcapNHadronicHit2++;
              initialHadronic+=pCaloHit->GetInputEnergy();
            }
            else if(fabs(m_sdhcalThresholds.at(2) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            {
              endcapNHadronicHit3++;
              initialHadronic+=pCaloHit->GetInputEnergy();
            }
          }
          noShowerHit = false;
        }
    }

    if(noShowerHit)
      return pandora::STATUS_CODE_SUCCESS;

    correctedEnergy-=initialHadronic; // Pull the initial energy of the HCAL hits from the total energy to correct

    /* std::cout << "NHadronicHit : " << NHadronicHit << std::endl;
    std::cout << "barrelNHadronicHit1 : " << barrelNHadronicHit1 << std::endl;
    std::cout << "barrelNHadronicHit2 : " << barrelNHadronicHit2 << std::endl;
    std::cout << "barrelNHadronicHit3 : " << barrelNHadronicHit3 << std::endl;

    std::cout << "endcapNHadronicHit1 : " << endcapNHadronicHit1 << std::endl;
    std::cout << "endcapNHadronicHit2 : " << endcapNHadronicHit2 << std::endl;
    std::cout << "endcapNHadronicHit3 : " << endcapNHadronicHit3 << std::endl; */

    //Parameters for geometric theta correction
    const float clusterCosTheta(this->GetCosTheta(pCluster)); //Cos theta for the endcap correction
    const float thetaAngle(std::acos(clusterCosTheta)); //Theta angle
    const float clusterSinTheta(std::sin(thetaAngle)); //Sin theta for the barrel correction

    //Sum the corrected number of hits for each tresholds
    NHadronicHit1 = this->GetCorrectedHitNumber(barrelNHadronicHit1, clusterSinTheta) + this->GetCorrectedHitNumber(endcapNHadronicHit1, clusterCosTheta);
    NHadronicHit2 = this->GetCorrectedHitNumber(barrelNHadronicHit2, clusterSinTheta) + this->GetCorrectedHitNumber(endcapNHadronicHit2, clusterCosTheta);
    NHadronicHit3 = this->GetCorrectedHitNumber(barrelNHadronicHit3, clusterSinTheta) + this->GetCorrectedHitNumber(endcapNHadronicHit3, clusterCosTheta);

    /* //Calculate the corrected total number of hits
    NHadronicHit = NHadronicHit1 + NHadronicHit2 + NHadronicHit3;

    //std::cout << "NHit corrected : " << NHadronicHit << std::endl;

    pandora::FloatVector m_energyConstantParameters;

    m_energyConstantParameters.push_back(0.0385315);
    m_energyConstantParameters.push_back(4.22584e-05);
    m_energyConstantParameters.push_back(-7.54657e-09);
    m_energyConstantParameters.push_back(0.0784297);
    m_energyConstantParameters.push_back(-5.69439e-05);
    m_energyConstantParameters.push_back(-4.95924e-08);
    m_energyConstantParameters.push_back(0.127212);
    m_energyConstantParameters.push_back(4.56414e-05);
    m_energyConstantParameters.push_back(1.41142e-08);

    // Quadratic correction
    const float alpha(m_energyConstantParameters.at(0) + m_energyConstantParameters.at(1)*NHadronicHit + m_energyConstantParameters.at(2)*NHadronicHit*NHadronicHit);
    const float beta(m_energyConstantParameters.at(3) + m_energyConstantParameters.at(4)*NHadronicHit + m_energyConstantParameters.at(5)*NHadronicHit*NHadronicHit);
    const float gamma(m_energyConstantParameters.at(6) + m_energyConstantParameters.at(7)*NHadronicHit + m_energyConstantParameters.at(8)*NHadronicHit*NHadronicHit);
    const float hadEnergy(NHadronicHit1*alpha + NHadronicHit2*beta + NHadronicHit3*gamma); */

    const float hadEnergy(NHadronicHit1*m_sdhcalThresholds.at(0) + NHadronicHit2*m_sdhcalThresholds.at(1) + NHadronicHit3*m_sdhcalThresholds.at(2)); //New linear hadronic energy 

    correctedEnergy += hadEnergy; //Compute the corrected energy

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ThetaNHitFunction::GetCosTheta(const pandora::Cluster *const pCluster) const
  {
    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

    return fabs(centroid.GetCosOpeningAngle(pandora::CartesianVector(0.f, 0.f, 1.f)));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ThetaNHitFunction::GetCorrectedHitNumber(int nHit, float cosTheta) const
  {
	  //std::cout << "nHit: " << nHit << ", cosTheta: " << cosTheta << std::endl;
    return nHit * (1 / (cosTheta));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ThetaNHitFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "LowEnergyCut", m_lowEnergyCut));

    pandora::FloatVector sdhcalThresholds;
    pandora::StatusCode statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "SdhcalThresholds", sdhcalThresholds);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_sdhcalThresholds = sdhcalThresholds;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(3 != m_sdhcalThresholds.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  PhiNHitFunction::PhiNHitFunction() :
       m_lowEnergyCut(3.f)
  {
        m_sdhcalThresholds.push_back(1);
        m_sdhcalThresholds.push_back(2);
        m_sdhcalThresholds.push_back(3);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PhiNHitFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    unsigned int NHadronicHit1 = 0;
    unsigned int NHadronicHit2 = 0;
    unsigned int NHadronicHit3 = 0;
  
    unsigned int barrelNHadronicHit1 = 0;
    unsigned int barrelNHadronicHit2 = 0;
    unsigned int barrelNHadronicHit3 = 0; 

    float initialBarrelHadronic = 0;

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_SUCCESS;

    if(correctedEnergy < m_lowEnergyCut)
      return pandora::STATUS_CODE_SUCCESS;

    unsigned int startingPseudoLayer(std::numeric_limits<unsigned int>::max());
 
    const pandora::StatusCode statusCode(ParticleIdHelper::GetStartingPseudoLayer(this->GetPandora(), pCluster, ParticleIdHelper::StartingLayerSettings(), startingPseudoLayer));

    // do not apply energy corrections if starting layer not found
    if(pandora::STATUS_CODE_SUCCESS != statusCode)
      return pandora::STATUS_CODE_SUCCESS;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    bool noShowerHit(true);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(pCaloHit->GetHitType() == pandora::HCAL)
        {
          if(pCaloHit->GetHitRegion() == pandora::BARREL)
          {
            if(fabs(m_sdhcalThresholds.at(0) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            { 
              barrelNHadronicHit1++;
              initialBarrelHadronic+=pCaloHit->GetInputEnergy();
            }
            else if(fabs(m_sdhcalThresholds.at(1) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            {
              barrelNHadronicHit2++;
              initialBarrelHadronic+=pCaloHit->GetInputEnergy();
            }
            else if(fabs(m_sdhcalThresholds.at(2) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
            {
              barrelNHadronicHit3++;
              initialBarrelHadronic+=pCaloHit->GetInputEnergy();
            }
          }
          noShowerHit = false;
        }
    }

    if(noShowerHit)
      return pandora::STATUS_CODE_SUCCESS;

    correctedEnergy-=initialBarrelHadronic; // Pull the initial energy of the HCAL hits from the total energy to correct

    /* std::cout << "NHadronicHit : " << NHadronicHit << std::endl;
    std::cout << "barrelNHadronicHit1 : " << barrelNHadronicHit1 << std::endl;
    std::cout << "barrelNHadronicHit2 : " << barrelNHadronicHit2 << std::endl;
    std::cout << "barrelNHadronicHit3 : " << barrelNHadronicHit3 << std::endl; */

    //Parameters for geometric phi correction
    const float clusterCosPhi(this->GetCosPhi(pCluster)); //Cos theta for the endcap correction

    //Sum the corrected number of hits for each tresholds
    NHadronicHit1 = this->GetCorrectedHitNumber(barrelNHadronicHit1, clusterCosPhi);
    NHadronicHit2 = this->GetCorrectedHitNumber(barrelNHadronicHit2, clusterCosPhi);
    NHadronicHit3 = this->GetCorrectedHitNumber(barrelNHadronicHit3, clusterCosPhi);

    const float correctedBarrelEnergy(NHadronicHit1*m_sdhcalThresholds.at(0) + NHadronicHit2*m_sdhcalThresholds.at(1) + NHadronicHit3*m_sdhcalThresholds.at(2)); //New barrel hadronic energy

    correctedEnergy += correctedBarrelEnergy; //Compute the corrected energy

    //outputFile << "Energy after : " << correctedEnergy <<  " ; " << std::endl;

    //outputFile.close();

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float PhiNHitFunction::GetCosPhi(const pandora::Cluster *const pCluster) const
  {
    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    pandora::CartesianVector zAxis(0.f, 0.f, 1.f);
  
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));
    pandora::CartesianVector projectedCentroid(zAxis.GetCrossProduct(centroid.GetCrossProduct(zAxis))); //Project the postion vector of the cluster in the XY-plane 
    float phiAngle = projectedCentroid.GetOpeningAngle(pandora::CartesianVector(1.f, 0.f, 0.f)); //Returns an angle between 0 and PI in rad
    while(phiAngle>M_PI_4/2) //Substract PI/4 until the angle is between -PI/8 and PI/8 rad
    {
        phiAngle-=M_PI_4;
    }

    return fabs(std::cos(phiAngle)); 
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float PhiNHitFunction::GetCorrectedHitNumber(int nHit, float cosPhi) const
  {
	  //std::cout << "nHit: " << nHit << ", cosTheta: " << cosTheta << std::endl;
    return nHit * (1 / (cosPhi));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PhiNHitFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "LowEnergyCut", m_lowEnergyCut));

    pandora::FloatVector sdhcalThresholds;
    pandora::StatusCode statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "SdhcalThresholds", sdhcalThresholds);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_sdhcalThresholds = sdhcalThresholds;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(3 != m_sdhcalThresholds.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    return pandora::STATUS_CODE_SUCCESS;
  }

//------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------  

CleanCluster::CleanCluster() :
    m_minCleanHitEnergy(0.5f),
    m_minCleanHitEnergyFraction(0.01f),
    m_minCleanCorrectedHitEnergy(0.1f)
{
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CleanCluster::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedHadronicEnergy) const
{
    const unsigned int firstPseudoLayer(this->GetPandora().GetPlugins()->GetPseudoLayerPlugin()->GetPseudoLayerAtIp());

    const float clusterHadronicEnergy(pCluster->GetHadronicEnergy());

    if (std::fabs(clusterHadronicEnergy) < std::numeric_limits<float>::epsilon())
        throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

    bool isFineGranularity(true);
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    // Loop over all constituent inner layer fine granularity hits, looking for anomalies
    for (pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerIterEnd = orderedCaloHitList.end();
        (layerIter != layerIterEnd) && isFineGranularity; ++layerIter)
    {
        const unsigned int pseudoLayer(layerIter->first);

        for (pandora::CaloHitList::const_iterator hitIter = layerIter->second->begin(), hitIterEnd = layerIter->second->end();
            hitIter != hitIterEnd; ++hitIter)
        {
            const pandora::CaloHit *const pCaloHit = *hitIter;

            if (this->GetPandora().GetGeometry()->GetHitTypeGranularity((*hitIter)->GetHitType()) > pandora::FINE)
            {
                isFineGranularity = false;
                break;
            }

            const float hitHadronicEnergy(pCaloHit->GetHadronicEnergy());

            if ((hitHadronicEnergy > m_minCleanHitEnergy) && (hitHadronicEnergy / clusterHadronicEnergy > m_minCleanHitEnergyFraction))
            {
                // Calculate new energy from surrounding layers
                float energyInPreviousLayer(0.);

                if (pseudoLayer > firstPseudoLayer)
                    energyInPreviousLayer = this->GetHadronicEnergyInLayer(orderedCaloHitList, pseudoLayer - 1);

                float energyInNextLayer(0.);

                if (pseudoLayer < std::numeric_limits<unsigned int>::max())
                    energyInNextLayer = this->GetHadronicEnergyInLayer(orderedCaloHitList, pseudoLayer + 1);

                const float energyInCurrentLayer = this->GetHadronicEnergyInLayer(orderedCaloHitList, pseudoLayer);

                // Calculate new energy estimate for hit and update cluster best energy estimate
                float energyInAdjacentLayers(energyInPreviousLayer + energyInNextLayer);

                if (pseudoLayer > firstPseudoLayer)
                    energyInAdjacentLayers /= 2.f;

                float newHitHadronicEnergy(energyInAdjacentLayers - energyInCurrentLayer + hitHadronicEnergy);
                newHitHadronicEnergy = std::max(newHitHadronicEnergy, m_minCleanCorrectedHitEnergy);

                if (newHitHadronicEnergy < hitHadronicEnergy)
                    correctedHadronicEnergy += newHitHadronicEnergy - hitHadronicEnergy;
            }
        }
    }

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float CleanCluster::GetHadronicEnergyInLayer(const pandora::OrderedCaloHitList &orderedCaloHitList, const unsigned int pseudoLayer) const
{
	pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.find(pseudoLayer);

    float hadronicEnergy(0.f);

    if (iter != orderedCaloHitList.end())
    {
        for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end(); hitIter != hitIterEnd; ++hitIter)
        {
            hadronicEnergy += (*hitIter)->GetHadronicEnergy();
        }
    }

    return hadronicEnergy;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CleanCluster::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinCleanHitEnergy", m_minCleanHitEnergy));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinCleanHitEnergyFraction", m_minCleanHitEnergyFraction));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinCleanCorrectedHitEnergy", m_minCleanCorrectedHitEnergy));

    return pandora::STATUS_CODE_SUCCESS;
}

}

